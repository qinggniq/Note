# 共识算法Raft
## 动机
[MIT6.824](https://pdos.csail.mit.edu/6.824/schedule.html)中使用Raft作为教学分布式系统中的分布式共识算法，最近正在做这个课程，写下这篇博客以更好的理解Raft这个算法。如果只是想去实现Raft，完成实验的话，看[论文](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)可能是更好的选择。
## 前言
> A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[^1]
分布式系统是组件位于不同网络主机的系统，它们通过消息传递来进行通信和协作。而分布式系统中的核心问题就是保证集群中的节点的数据完全形同并且能够对某个题案（Proposal）达成一致。由于网络自身的不稳定性和主机的不稳定性，让分布式系统中的**一致性**难以保证。而**分布式共识算法**就是用来保证分布式系统共识的方法。

Raft是基于Paxos算法的简化版本，它被设计出来的目的就是比Paxos更易理解和实现的同时还能保证安全性和效率。
## 背景
一致性算法是从**复制状态机**（Replicated State Machine）的背景下提出的。**复制状态机**是实现主从备份的一种方法。
![复制状态机]](https://mr-dai.github.io/img/raft/rsm-architecture.png)
> 图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。
上面步骤如下：
1. 客户端向集群中的任意节点发送请求，请求执行操作；
2. 共识模块将操作作为日志追加到集群的所有机器上；
3. 当日志被**安全**备份后，将操作应用到自己的状态机中；
4. 返回相应的结果给客户端。

Raft使用**复制状态机**进行主从备份，分布式共识算法的职责就是**以固定的顺序将指定的命令备份到集群中的其他实例上**。

## 基础
Raft之所以简单，是因为它将分布式共识这个问题分解成了三个模块——**选举模块**（Leader election）、**日志复制模块**（Log replication）和**安全模块**（Safety），并且仅使用了两个**远程过程调用**（RPC）来实现这些功能。它将集群中的节点分为三种角色——**领导**（Leader）、**候选人**（Candidate）和**追随者**（Follower），并且相比于Paxos提供了更强的限制：
1. 有效的**领导**（Leader）是唯一的。
2. **日志记录**（Log entires）只能从**领导**（Leader）给其他节点，而**追随者**从来不主动发送信息，只响应Leader和Candidate的消息。
3. 客户端只和Leader交互，如果开始客户端将消息发给了其他节点，那么节点会将消息转发给Leader。（？？？）
4. Raft在**选举**过程中使用随机定时器，并且提供了**共同一致**（joint consensus）来解决集群成员变更的问题。

### 一些名词
**任期**
Raft引入了**任期**(Term)这个概念，**每一次的选举**都会使Term加一，而并不是**每一次更换领导**使Term加一，因为有可能出现一次选举没有产生Leader的情况。这个状态十分有用，Follower根据Term判断失效的Leader（之前的Leader因为某些原因挂掉了，后来选出了新的Leader，而旧Leader以为自己还是Leader给Follower发心跳包，而因为每次选举都会使Term加一，所以旧Leader的Term必然会比当前未失效的节点的Term小），还可以通过Term和Index来判断Follower日志是否失效。

**附加日志**
client发送操作给Leader，Leader将操作打包为日志后发送给其他Follower，Follower收到后根据日志中的信息判断是否接受日志，并返回相应的结果。

**心跳包**
和**附加日志**的区别仅限于**心跳包**中没有实际的操作命令，用于Leader维护地位。

**非拜占庭式错误** 指简单的死机、断网这种不会发出错误结果的错误。
**拜占庭式错误**指节点因为应用bug执行错误的结果。


### 在整个过程中需要保证的性质
|       特性       |                                                          解释                                                          |
| :--------------: | :--------------------------------------------------------------------------------------------------------------------: |
|    选举安全性    |                                  对于一个给定的任期号，最多只会有一个领导人被选举出来                                  |
| 领导人只附加原则 |                                     领导人绝对不会删除或者覆盖自己的日志，只会增加                                     |
|   日志匹配原则   |      如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同      |
|  领导人完全特性  |                如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中                |
|  状态机安全特性  | 如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志 |
### 节点需维护的状态
**状态**：

| 状态          | 所有服务器上持久存在的                                               |
| ------------- | -------------------------------------------------------------------- |
| `currentTerm` | 节点的当前任期号                                                     |
| `votedFor`    | 这个节点要投票的节点的ID                                             |
| `log[]`       | 日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号 |

| 状态          | 所有服务器上经常变的                                                                                                                               |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `commitIndex` | 已知知道的已经被提交了的日志的`index`，Leader根据当前任期的日志是否被绝大多数Follower接受更新，Follower根据`AppendEntries`中`leaderCommit`属性更新 |
| lastApplied   | 一旦`lastApplied` < `commitIndex`，那么把这中间的日志提交到自己状态机中去                                                                          |

| 状态         | 在领导人里经常改变的 （选举后重新初始化）                                              |
| ------------ | -------------------------------------------------------------------------------------- |
| nextIndex[]  | 对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一） |
| matchIndex[] | 对于每一个服务器，已经复制给他的日志的最高索引值，初始化为-1                           |



## 选举
**请求投票 RPC**：

由候选人负责调用用来征集选票（5.2 节）

| 参数         | 解释                         |
| ------------ | ---------------------------- |
| term         | 候选人的任期号               |
| candidateId  | 请求选票的候选人的 Id        |
| lastLogIndex | 候选人的最后日志条目的索引值 |
| lastLogTerm  | 候选人最后日志条目的任期号   |

| 返回值      | 解释                                       |
| ----------- | ------------------------------------------ |
| term        | 当前任期号，以便于候选人去更新自己的任期号 |
| voteGranted | 候选人赢得了此张选票时为真                 |

**请求投票 RPC**：

由候选人负责调用用来征集选票（5.2 节）

| 参数         | 解释                         |
| ------------ | ---------------------------- |
| term         | 候选人的任期号               |
| candidateId  | 请求选票的候选人的 Id        |
| lastLogIndex | 候选人的最后日志条目的索引值 |
| lastLogTerm  | 候选人最后日志条目的任期号   |

| 返回值      | 解释                                       |
| ----------- | ------------------------------------------ |
| term        | 当前任期号，以便于候选人去更新自己的任期号 |
| voteGranted | 候选人赢得了此张选票时为真                 |

**接收者实现：**

1. 如果`term < currentTerm`返回 `false` （**接受原则1**）
2. 如果 `votedFor` 为空或者为 `candidateId`，并且候选人的日志至少和自己一样新，那么就投票给他 （**接受原则2**）

**所有服务器需遵守的规则：**

所有服务器：

* 如果commitIndex > lastApplied，那么就 lastApplied 加一，并把log[lastApplied]应用到状态机中
* 如果接收到的 RPC 请求或响应中，任期号T > currentTerm，那么就令currentTerm 等于 T，并切换状态为跟随者（5.1 节）

Follower：

* 响应来自候选人和领导者的请求
* 如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人

Candidate：

* 在转变成候选人后就立即开始选举过程
	* 自增当前的任期号（currentTerm）
	* 给自己投票
	* 重置选举超时计时器
	* 发送请求投票的 RPC 给其他所有服务器
* 如果接收到大多数服务器的选票，那么就变成领导人
* 如果接收到来自新的领导人的附加日志 RPC，转变成跟随者
* 如果选举过程超时，再次发起一轮选举

Leader：

* 一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时
* 如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端
* 如果对于一个跟随者，最后日志条目的索引值大于等于 `nextIndex`，那么：发送从 `nextIndex` 开始的所有日志条目：
	* 如果成功：更新相应跟随者的 `nextIndex`和 `matchIndex`
	* 如果因为日志不一致而失败，减少 `nextIndex` 重试

* 如果存在一个满足`N > commitIndex`的 `N`，并且大多数的`matchIndex[i] ≥ N`成立，并且`log[N].term == currentTerm`成立，那么令 `commitIndex` 等于这个 `N` （5.3 和 5.4 节）

### 选举过程
初始时，每个节点的都是Follower，Follower会维护一个election timeout，超时时间是在一个范围内的随机值，当定时器超时之前没有接受到Leader发过来的心跳包或者Candidate发过来的投票请求，那么Follower就会认为当前集群没有Leader和Candidate，那么就会
1. 把自己变成Candidate；
2. `Term`加一；
3. 给自己投票；
4. 向其他节点发送`RequestVote`来获取其他节点的支持。

投票会产生三种结果：
1. **选举成功**，也就是获得投票数超过一半，那么将自己的状态改为Leader，并且立刻发送心跳包给其他节点；
2. **因为超时而导致选举失败**，如果在选举超时时间中**没有任何一个Candidate获得绝大多数节点的支持**，那么此次选举失败，立刻开启下一轮选举，由于选举定时器的超时时间是随机设置的并且远大于**广播时间**，选举超时的情况不会经常发生；
3. **因为其他Leader选举成功而选举失败**，也就是在选举过程中**有一个Candidate获得了绝大多数节点的支持**，那么新选举出的Leader会发送心跳包给自己，此时因此结束选举。

### 投票原则
投票原则指——接受者根据什么决定给这个Candidate投票还是不投票？在**接受者实现**中提到两个**接收原则**

**原则1**：如果`term < currentTerm`返回 `false` 
这是为了避免一个crash掉很久的Follower尝试发起投票而定的原则，显然一个crash掉很久的Candidate没有资格获得更新的Follower的投票。（？？？）

**原则2**：如果 `votedFor` 为空或者为 `candidateID`，并且候选人的日志至少和自己一样新，那么就投票给他
这个原则分为两个部分，一部分是“如果 `votedFor` 为空或者为 `candidateId`”，另一部分是“候选人的日志至少和自己一样新”，前者很好理解，就是如果自己已经给其他Candidate投票了，那么就不能再给另一个Candidate投票了，判断是否为CandidateID是考虑可能之前同意了这个候选人的投票请求，然而那个包因为网络原因重复发送，自己之前的reply也因为网络原因而丢失，所以如果不判断是不是之前投给那个候选人的话，可能会造成误判。而后者“候选人的日志至少和自己一样新”这个原则是保证**领导人完全特性**的重要步骤。


### votedFor更新时机
在论文中只提到在收到`RequestVote`请求时可能会更改`votedFor`状态从`null`到`candidateId`，那么什么时候将`votedFor`改回`null`呢？
我们先假设**不将`votedFor`改回`null`**的情况：
> 集群中有三个节点A，B，C，初始时它们三个的状态如下


|    状态     | A        |    B     |    C     |
| :---------: | :------- | :------: | :------: |
|    role     | Follower | Follower | Follower |
|  votedFor   | null     |   null   |   null   |
| currentTerm | 0        |    0     |    0     |

> A定时器先超时，将自己变成`Candidate`状态，给自己投票，`currentTerm++`，想其他节点发送`RequestVote`请求


|    状态     | A         |    B     |    C     |
| :---------: | :-------- | :------: | :------: |
|    role     | Candidate | Follower | Follower |
|  votedFor   | A         |   null   |   null   |
| currentTerm | 1         |    0     |    0     |
> B和C接收到A的请求并投票给A


|    状态     | A         |    B     |    C     |
| :---------: | :-------- | :------: | :------: |
|    role     | Candidate | Follower | Follower |
|  votedFor   | A         |    A     |    A     |
| currentTerm | 1         |    1     |    1     |

> A挂起，B先超时，开始选选举


|    状态     | A         |    B     |    C     |
| :---------: | :-------- | :------: | :------: |
|    role     | Candidate | Follower | Follower |
|  votedFor   | A         |    B     |    A     |
| currentTerm | 1         |    2     |    1     |
那么问题来了，假设不清空`votedFor`状态，那么C不可能投票给B，B不能获得绝大多数节点的同意，那么也成为不了Leader，而即使超时C开始成为候选人，那么B也不会投票给C，陷入了死锁的状态。

那么什么时候应该给`votedFor`置空呢？首先考虑一下什么时候算是在某轮选举**第一次投票**，开始选举时，候选人有一步`currentTerm++`的操作，而Follower是没有的，所以`RequestVote`第一次到达某个Follower的时候必然`currentTerm < Term`，而另一个Candidate发送过来时由于Follower的`currentTerm`已经更新，所以`currentTerm == Term`，那么将`votedFor`置空操作放置在`RequestVote` 中`currentTerm < Term`判断为真里面比较合适。

## 

**附加日志 RPC**：

由领导人负责调用来复制日志指令；也会用作heartbeat

| 参数         | 解释                                                               |
| ------------ | ------------------------------------------------------------------ |
| term         | 领导人的任期号                                                     |
| leaderId     | 领导人的 Id，以便于跟随者重定向请求                                |
| prevLogIndex | 新的日志条目紧随之前的索引值                                       |
| prevLogTerm  | prevLogIndex 条目的任期号                                          |
| entries[]    | 准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率） |
| leaderCommit | 领导人已经提交的日志的索引值                                       |

| 返回值  | 解释                                                        |
| ------- | ----------------------------------------------------------- |
| term    | 当前的任期号，用于领导人去更新自己                          |
| success | 跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真 |

接收者实现：

1. 如果 `term < currentTerm` 就返回 false （5.1 节）
2. 如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false （5.3 节）
3. 如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 （5.3 节）
4. 附加日志中尚未存在的任何新条目
5. 如果 `leaderCommit > commitIndex`，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个

**所有服务器需遵守的规则**：

所有服务器：

* 如果`commitIndex > lastApplied`，那么就 lastApplied 加一，并把`log[lastApplied]`应用到状态机中（5.3 节）
* 如果接收到的 RPC 请求或响应中，任期号`T > currentTerm`，那么就令 currentTerm 等于 T，并切换状态为跟随者（5.1 节）

跟随者（5.2 节）：

* 响应来自候选人和领导者的请求
* 如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人

候选人（5.2 节）：

* 在转变成候选人后就立即开始选举过程
	* 自增当前的任期号（currentTerm）
	* 给自己投票
	* 重置选举超时计时器
	* 发送请求投票的 RPC 给其他所有服务器
* 如果接收到大多数服务器的选票，那么就变成领导人
* 如果接收到来自新的领导人的附加日志 RPC，转变成跟随者
* 如果选举过程超时，再次发起一轮选举

领导人：

* 一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时（5.2 节）
*  如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）
*  如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：
	* 如果成功：更新相应跟随者的 nextIndex 和 matchIndex
	* 如果因为日志不一致而失败，减少 nextIndex 重试
* 如果存在一个满足`N > commitIndex`的 N，并且大多数的`matchIndex[i] ≥ N`成立，并且`log[N].term == currentTerm`成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）

![图 2 ](./images/raft-图2.png)

> 图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。









## 复制状态机

# Draft
## 选主 
- 请求投票
## 正常操作
- `requestVote()`
- `duplicateLogEntry()`
- 心跳，不带`command`的`duplicateLogEntry()`操作
- 绝大多数**Follower**执行并提交之后才发`response`。=> 确保了在**Leader**挂了之后的选主阶段选出来的新**Leader**包含了所有的`committed logs`
- 

## 安全性和一致性
### leader挂了
- `checkStatus()`归纳法证明正确性。
- `(index, term)`确定选**Leader**的时候选哪个。 => 用于保证**Leader**里面有所有`committed logs`。
### follower的一致性
- `next_index, (index, term), checkStatus()`来检查直到第一个状态一致的log。
### follower挂了
- **Leader**一直retry就行。
## 废弃的Leader
- 旧的**Leader**可能是网卡了一下，然后新的**Leader**被选出来了，所以旧**Leader**会重新`duplicateLogEntry()`
- `(index, term)`用于确定`follower()`是不是再认回来原来的**Leader**。
- $term_{old\_leader} > term_{follower\_or\_new\_leader}$，那么现在的**Leader**退位给旧**Leader**，否则旧**Leader**变成**Follower**。
## 用户规则
- 设置`timeout`，超时重发即可。
- 保证`command`**正好一次**执行。
- 大于等于一次：执行完成才提交。
- 不超过一次：通过给已提交的`command`添加`unique id`确保不会重复执行。
## 配置更改
- 2phase提交。
- *joint consensus*阶段用于确保在$C_{old,new}$的时候不会产生新的**Leader**。

## 问题
- `committed log`是**follower**自己确定的还是**leader**确定的 => **Leader**确定的。
> 如果选举超时并且没有从**Leader**收到`AppendEntries`或者给**Candidate**发投票，那么将自己变成**Candidate**

## 要点
- **提交**，[leader视角]在复制到大多数的服务器上时，就会提交，[follower视角]如果它知道有些日志已经被提交，那么它会将这个日志放到自己的状态机中。[1]
- **安全性**：
  - 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。
  - 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。
    1. 这是因为**在leader的log是只增加不会修改和减少的**
    2. 这个是根据`appendEntries`里面检查一致性决定的，它保证上一条记录相同，那么这一条记录也相同的话，那么前面的全部相同。
**正常情况**下是一致的，如果不一致那么就把**follower**不一致的记录覆盖为**leader**的记录

> 如何保证apply到状态机的是一致的?）
> 答：根据条件1，“如果它知道有些日志已经被提交，那么它会将这个日志放到自己的状态机中。”在确保提交日志一致性的情况下使得状态机保持一致性。

**Leader**开始自己的任期的时候就会把nexIndex[]设置为自己的最大log index + 1，然后根据**Follower**的一致性检查来一步步确定每个**follower**的状态。（然后如果大部分的sever上都有这个log，就会提交）
> 之前提交的怎么算？
> 如何保证每个状态机执行相同顺序的指令？。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。

通过在选主的时候增加**限制**来保证选出来的**Leader**拥有提交过的所有记录。这个限制就是：
- 新选出来的**Leader**的log必须比绝大多数的服务器节点新。通过term和index比较，Term越大越新，index越长越新。

> 为什么在5.4.2节（b）阶段S5不能获得S2的选票？为什么S5不是任期2获得的选票，而不是S2在任期2当上Leader

前一轮 Term 未 Commit 的 LogEntry 的 Commit 依赖于高轮 Term LogEntry 的 Commit。

只有领导人当前任期里的日志条目通过计算副本数目可以被提交（只有当前任期的log提交并且大部分的server都将logappend到自己的logs里面才能算提交），也就是说之前的不用管。
**然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。**这个意思是，之前任期（比如现在的Term是5，之前的是3）如果Term是3的某个log是被大多数server拥有，那么也不能确定它就是被提交了的。（因为有可能在上一个任期2虽然有大部分sever有记录a，但是在leader A提交之前崩溃掉了，这个时候如果LeaderA恢复执行任期4的时候尝试提交记录a的话，有可能被另一个任期3的取代掉，然后覆盖已经提交的2）如果采用新任期的计算方法的话，那么哪个任期3的sever根本不可能选举成功。

## 配置更改（集群成员变化）
引入**共同一致**阶段。
- 日志条目被复制给集群中新、老配置的所有服务器。
- 新、旧配置的服务器都可以成为领导人。
- 达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。

> 为什么强制Cold,new同时有的才能被选举为Leader