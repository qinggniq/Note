# 共识算法Raft

## 动机

[MIT6.824](https://pdos.csail.mit.edu/6.824/schedule.html)中使用Raft作为教学分布式系统中的分布式共识算法，最近正在做这个课程，写下这篇博客以更好的理解Raft这个算法。如果只是想去实现Raft，完成实验的话，看[论文](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)可能是更好的选择。

## 前言

> A distributed system is a system whose components are located on different networked computers, which communicate and coordinate their actions by passing messages to one another.[^1]

分布式系统是组件位于不同网络主机的系统，它们通过消息传递来进行通信和协作。而分布式系统中的核心问题就是保证集群中的节点的数据完全形同并且能够对某个题案（Proposal）达成一致。由于网络自身的不稳定性和主机的不稳定性，让分布式系统中的**一致性**难以保证。而**分布式共识算法**就是用来保证分布式系统共识的方法。

Raft是基于Paxos算法的简化版本，它被设计出来的目的就是比Paxos更易理解和实现的同时还能保证安全性和效率。

## 背景

一致性算法是从**复制状态机**（Replicated State Machine）的背景下提出的。**复制状态机**是实现主从备份的一种方法。

![复制状态机]](https://mr-dai.github.io/img/raft/rsm-architecture.png)

> 图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。
上面步骤如下：

1. 客户端向集群中的任意节点发送请求，请求执行操作；
2. 共识模块将操作作为日志追加到集群的所有机器上；
3. 当日志被**安全**备份后，将操作应用到自己的状态机中；
4. 返回相应的结果给客户端。

Raft使用**复制状态机**进行主从备份，分布式共识算法的职责就是**以固定的顺序将指定的命令备份到集群中的其他实例上**。

## 基础

Raft之所以简单，是因为它将分布式共识这个问题分解成了三个模块——**选举模块**（Leader election）、**日志复制模块**（Log replication）和**安全模块**（Safety），并且仅使用了两个**远程过程调用**（RPC）来实现这些功能。它将集群中的节点分为三种角色——**领导**（Leader）、**候选人**（Candidate）和**追随者**（Follower），并且相比于Paxos提供了更强的限制：

1. 有效的**领导**（Leader）是唯一的。
2. **日志记录**（Log entires）只能从**领导**（Leader）给其他节点，而**追随者**从来不主动发送信息，只响应Leader和Candidate的消息。
3. 客户端只和Leader交互，如果开始客户端将消息发给了其他节点，那么节点会将消息转发给Leader。（？？？）
4. Raft在**选举**过程中使用随机定时器，并且提供了**共同一致**（joint consensus）来解决集群成员变更的问题。

### 一些名词

**任期**
![任期图](https://raw.githubusercontent.com/qinggniq/Note/master/GO/images/Raft/raft-%E5%9B%BE5.png)
> 图2：时间被划分成一个个的任期，每个任期开始都是一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。

Raft引入了**任期**(Term)这个概念，**每一次的选举**都会使Term加一，而并不是**每一次更换领导**使Term加一，因为有可能出现一次选举没有产生Leader的情况。这个状态十分有用，Follower根据Term判断失效的Leader（之前的Leader因为某些原因挂掉了，后来选出了新的Leader，而旧Leader以为自己还是Leader给Follower发心跳包，而因为每次选举都会使Term加一，所以旧Leader的Term必然会比当前未失效的节点的Term小）。

**附加日志**
client发送操作给Leader，Leader将操作打包为日志后发送给其他Follower，Follower收到后根据日志中的信息判断是否接受日志，并返回相应的结果。

**心跳包**
和**附加日志**的区别仅限于**心跳包**中没有实际的操作命令，用于Leader维护地位。

**非拜占庭式错误** 指简单的死机、断网这种不会发出错误结果的错误。
**拜占庭式错误**指节点因为应用bug执行错误的结果。

### **在整个过程中需要保证的性质**

|       特性       |                                                          解释                                                          |
| :--------------: | :--------------------------------------------------------------------------------------------------------------------: |
|    选举安全性    |                                  对于一个给定的任期号，最多只会有一个领导人被选举出来                                  |
| 领导人只附加原则 |                                     领导人绝对不会删除或者覆盖自己的日志，只会增加                                     |
|   日志匹配原则   |      如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同      |
|  领导人完全特性  |                如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中                |
|  状态机安全特性  | 如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志 |

> 表一：Raft在任何时候都需要保证的特性

### 节点需维护的状态

**状态**：
| 状态          | 所有服务器上持久存在的                                               |
| ------------- | -------------------------------------------------------------------- |
| `currentTerm` | 节点的当前任期号                                                     |
| `votedFor`    | 这个节点要投票的节点的ID                                             |
| `log[]`       | 日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号 |

| 状态          | 所有服务器上经常变的                                                                                                                               |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `commitIndex` | 已知知道的已经被提交了的日志的`index`，Leader根据当前任期的日志是否被绝大多数Follower接受更新，Follower根据`AppendEntries`中`leaderCommit`属性更新 |
| lastApplied   | 一旦`lastApplied` < `commitIndex`，那么把这中间的日志提交到自己状态机中去                                                                          |

| 状态         | 在领导人里经常改变的 （选举后重新初始化）                                              |
| ------------ | -------------------------------------------------------------------------------------- |
| nextIndex[]  | 对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一） |
| matchIndex[] | 对于每一个服务器，已经复制给他的日志的最高索引值，初始化为-1                           |

## **Raft基础**

一般Raft集群中包含$2N + 1, N >= 1$个服务器节点，这样的集群一般可以容忍$N$个节点的失效，每个服务器有三个状态：Leader、Candidate、Follower。在正常情况下集群中里面只有一个Leader，其他全部都是Follower，Leader向Follower发送复制日志让集群中的节点保持一致，Follower接收Leader发过来的包并进行处理，Candidate状态是集群系统中检测到Leader不存在时引入的**选主**（Leader election）阶段中产生的角色。

![Raft状态转换](https://raw.githubusercontent.com/qinggniq/Note/blob/master/GO/MIT6.824/imags/Raft/raft-图4.png)
> 图3：服务器状态转换图。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导者。在一个任期内，领导人一直都会是领导人直到自己宕机了。

## 选举

**请求投票 RPC**：

由候选人负责调用用来征集选票（5.2 节）
| 参数         | 解释                         |
| ------------ | ---------------------------- |
| term         | 候选人的任期号               |
| candidateId  | 请求选票的候选人的 Id        |
| lastLogIndex | 候选人的最后日志条目的索引值 |
| lastLogTerm  | 候选人最后日志条目的任期号   |

| 返回值      | 解释                                       |
| ----------- | ------------------------------------------ |
| term        | 当前任期号，以便于候选人去更新自己的任期号 |
| voteGranted | 候选人赢得了此张选票时为真                 |

**请求投票 RPC**：

由候选人负责调用用来征集选票（5.2 节）

| 参数         | 解释                         |
| ------------ | ---------------------------- |
| term         | 候选人的任期号               |
| candidateId  | 请求选票的候选人的 Id        |
| lastLogIndex | 候选人的最后日志条目的索引值 |
| lastLogTerm  | 候选人最后日志条目的任期号   |

| 返回值      | 解释                                       |
| ----------- | ------------------------------------------ |
| term        | 当前任期号，以便于候选人去更新自己的任期号 |
| voteGranted | 候选人赢得了此张选票时为真                 |

**接收者实现：**

1. 如果`term < currentTerm`返回 `false` （**接受原则1**）
2. 如果 `votedFor` 为空或者为 `candidateId`，并且候选人的日志至少和自己一样新，那么就投票给他 （**接受原则2**）

**所有服务器需遵守的规则：**

所有服务器：

* 如果commitIndex > lastApplied，那么就 lastApplied 加一，并把log[lastApplied]应用到状态机中
* 如果接收到的 RPC 请求或响应中，任期号T > currentTerm，那么就令currentTerm 等于 T，并切换状态为跟随者（5.1 节）

Follower：

* 响应来自候选人和领导者的请求
* 如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人

Candidate：

* 在转变成候选人后就立即开始选举过程
  * 自增当前的任期号（currentTerm）
  * 给自己投票
  * 重置选举超时计时器
  * 发送请求投票的 RPC 给其他所有服务器
* 如果接收到大多数服务器的选票，那么就变成领导人
* 如果接收到来自新的领导人的附加日志 RPC，转变成跟随者
* 如果选举过程超时，再次发起一轮选举

Leader：

* 一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时
* 如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端
* 如果对于一个跟随者，最后日志条目的索引值大于等于 `nextIndex`，那么：发送从 `nextIndex` 开始的所有日志条目：
  * 如果成功：更新相应跟随者的 `nextIndex`和 `matchIndex`
  * 如果因为日志不一致而失败，减少 `nextIndex` 重试
* 如果存在一个满足`N > commitIndex`的 `N`，并且大多数的`matchIndex[i] ≥ N`成立，并且`log[N].term == currentTerm`成立，那么令 `commitIndex` 等于这个 `N` （5.3 和 5.4 节）
![图 2 ](./images/raft-图2.png)

> 图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。

### 选举过程

初始时，每个节点的都是Follower，Follower会维护一个`election timeout`，超时时间是在一个范围内的随机值，当定时器超时之前没有接受到Leader发过来的心跳包或者Candidate发过来的投票请求，那么Follower就会认为当前集群没有Leader和Candidate，那么就会

1. 把自己变成Candidate；
2. `Term`加一；
3. 给自己投票；
4. 向其他节点发送`RequestVote`来获取其他节点的支持。

投票会产生三种结果：

1. **选举成功**，也就是获得投票数超过一半，那么将自己的状态改为Leader，并且立刻发送心跳包给其他节点；
2. **因为超时而导致选举失败**，如果在选举超时时间中**没有任何一个Candidate获得绝大多数节点的支持**，那么此次选举失败，立刻开启下一轮选举，由于选举定时器的超时时间是随机设置的并且远大于**广播时间**，选举超时的情况不会经常发生；
3. **因为其他Leader选举成功而选举失败**，也就是在选举过程中**有一个Candidate获得了绝大多数节点的支持**，那么新选举出的Leader会发送心跳包给自己，此时因此结束选举。

### 投票原则

投票原则指——接受者根据什么决定给这个Candidate投票还是不投票？在**接受者实现**中提到两个**接收原则**

**原则1**：如果`term < currentTerm`返回 `false`

这是为了避免一个crash掉很久的Follower尝试发起投票而定的原则，显然一个crash掉很久的Candidate没有资格获得更新的Follower的投票。

**原则2**：如果 `votedFor` 为空或者为 `candidateID`，并且候选人的日志至少和自己一样新，那么就投票给他

这个原则分为两个部分，一部分是“如果 `votedFor` 为空或者为 `candidateId`”，另一部分是“候选人的日志至少和自己一样新”，前者很好理解，就是如果自己已经给其他Candidate投票了，那么就不能再给另一个Candidate投票了，判断是否为CandidateID是考虑可能之前同意了这个候选人的投票请求，然而那个包因为网络原因重复发送，自己之前的reply也因为网络原因而丢失，所以如果不判断是不是之前投给那个候选人的话，可能会造成误判。而后者“候选人的日志至少和自己一样新”这个原则是保证**领导人完全特性**的重要步骤。

### votedFor更新时机

在论文中只提到在收到`RequestVote`请求时可能会更改`votedFor`状态从`null`到`candidateId`，那么什么时候将`votedFor`改回`null`呢？
我们先假设**不将`votedFor`改回`null`**的情况：
> 集群中有三个节点A，B，C，初始时它们三个的状态如下

|    状态     | A        |    B     |    C     |
| :---------: | :------- | :------: | :------: |
|    role     | Follower | Follower | Follower |
|  votedFor   | null     |   null   |   null   |
| currentTerm | 0        |    0     |    0     |

> A定时器先超时，将自己变成`Candidate`状态，给自己投票，`currentTerm++`，想其他节点发送`RequestVote`请求

|    状态     | A         |    B     |    C     |
| :---------: | :-------- | :------: | :------: |
|    role     | Candidate | Follower | Follower |
|  votedFor   | A         |   null   |   null   |
| currentTerm | 1         |    0     |    0     |

> B和C接收到A的请求并投票给A

|    状态     | A         |    B     |    C     |
| :---------: | :-------- | :------: | :------: |
|    role     | Candidate | Follower | Follower |
|  votedFor   | A         |    A     |    A     |
| currentTerm | 1         |    1     |    1     |

> A挂起，B先超时，开始选选举

|    状态     | A         |    B     |    C     |
| :---------: | :-------- | :------: | :------: |
|    role     | Candidate | Follower | Follower |
|  votedFor   | A         |    B     |    A     |
| currentTerm | 1         |    2     |    1     |

那么问题来了，假设不清空`votedFor`状态，那么C不可能投票给B，B不能获得绝大多数节点的同意，那么也成为不了Leader，而即使超时C开始成为候选人，那么B也不会投票给C，陷入了死锁的状态。

那么什么时候应该给`votedFor`置空呢？首先考虑一下什么时候算是在某轮选举**第一次投票**，开始选举时，候选人有一步`currentTerm++`的操作，而Follower是没有的，所以`RequestVote`第一次到达某个Follower的时候必然`currentTerm < Term`，而另一个Candidate发送过来时由于Follower的`currentTerm`已经更新，所以`currentTerm == Term`，那么将`votedFor`置空操作放置在`RequestVote` 中`currentTerm < Term`判断为真里面比较合适。

## 日志复制

### **RPC细节**

**附加日志 RPC**：
由领导人负责调用来复制日志指令；也会用作heartbeat

| 参数         | 解释                                                               |
| ------------ | ------------------------------------------------------------------ |
| term         | 领导人的任期号                                                     |
| leaderId     | 领导人的 Id，以便于跟随者重定向请求                                |
| prevLogIndex | 新的日志条目紧随之前的索引值                                       |
| prevLogTerm  | prevLogIndex 条目的任期号                                          |
| entries[]    | 准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率） |
| leaderCommit | 领导人已经提交的日志的索引值                                       |

| 返回值  | 解释                                                        |
| ------- | ----------------------------------------------------------- |
| term    | 当前的任期号，用于领导人去更新自己                          |
| success | 跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真 |

接收者实现：

1. 如果 `term < currentTerm` 就返回 false ；
2. 如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false ；
3. 如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 ；
4. 附加日志中尚未存在的任何新条目；
5. 如果 `leaderCommit > commitIndex`，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个。

### **日志复制过程**

#### **一致性判断条件**

在描述Follower和Leader是如何处理日志复制之前需要解释一下表一中“日志匹配原则”：

> **日志匹配原则**： 如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同

那么这个特性是如何保证的呢？

这个特性可以分为两个部分：

1. 如果两个日志在相同的索引位置的日志条目的任期号相同，那么他们存储的指令相同。
2. 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。

第一个特性是通过**领导人只追加特性**，那么领导人最多在一个Term里指定的日志索引位置创建一条日志条目，同时根据领导人只追加特性那么日志条目在日志中的位置从来不会改变。

第二个特性根据附加日志RPC的一个简单的一致性检查所保证。也就是Follower在执行`AppendEntries` RPC的时候对于参数的检查，检查参数中`PrevLogIndex`和`PrevLogTerm`是不是和自己节点的日志一样的。它的正确性证明类似于数学归纳法：

1. 空的日志状态必然满足日志匹配原则；
2. 假设在日志长度为$N$的时候符合日志匹配原则，那么在一致性检查后，新加入了日志后的日志长度为$N + 1$的日志必然符合日志匹配原则；
3. 证毕。

#### **Follower**

Follower主要是通过检查`AppendEntries` Rpc中参数的`prevLogIndex`和`prevLogTerm`来判断日志是否冲突，通过`LeaderTerm`来检查日志是不是由过期Leader发送的。下面讲Raft如何处理Follower节点日志不一致的问题。

 **对日志不一致问题的处理**
由于网络和主机崩溃原因，一些Follower中的日志条目可能会出现日志不一致的问题，一般是要么比Leader的日志少，要么比Leader的日志多并且在特定的Index的日志的Term不一致。
![日志不一致问题图](https://raw.githubusercontent.com/qinggniq/Note/GO/MIT6.824/imags/Raft/raft-日志不匹配图.png)
> 图4：新领导人选举后其他节点可能的日志状态

如上图，当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。

而Leader处理不一致的问题很简单，就是强制让Follower的日志和Leader的日志一样，所以Follower中与Leader不一致的日志就会被覆盖。对于Follower这边，Follower需要根据一致性检查来决定是否替换截断、替换自己的日志，具体的规则见**RPC细节**中的“接收者实现”。

#### **Leader**

Leader在会把接收到的command打包为Log日志格式发送给Follower，如果**某个日志被绝大多数节点成功复制并且这条日志的Term和Leader的当前Term相同**，那么Leader会将这条日志和之前的日志设置为提交。而对于返回失败的RPC调用，Leader会将用于控制发送日志内容的`nextIndex[]`中对应节点的值减一然后重试，直到成功（这里有个实现上的优化，就是Follower在检测到日志冲突的时候返回失败的同时将日志中上一个Term的最后一个Log的Index返回给Leader，Leader根据这个信息决定`nextIndex`值的改变，这样把时间复杂度从$O(length(logs)))$转化为了$O(length(terms of logs))$）。

上面的提交条件中有两个点：

1. **被绝大多数节点成功复制**：这个条件保证了在选举的过程中选出来的Leader必然包含了成功提交的日志，因为选举条件：**候选人的日志条目至少比自己的新**保证了新Leader的日志知道比绝大多数节点新，根据鸽巢原理可知候选人必然拥有所有被提交的日志。
2. **日志的Term和Leader当前的Term相同**：这是为了避免**在提交旧Term时的日志时可能会发生的特殊情况**，下面举例说明这种特殊情况。

**提交旧Term时期的日志**
![复制之前任期的日志图](https://raw.githubusercontent.com/qinggniq/Note/GO/MIT6.824/imags/Raft/raft-复制之前任期的日志.png)
> 图5：复制之前Term时期的日志

上图展示了五个时期的节点日志，但是实际上只有四个时期的节点日志，后两个情况是提交条件为“被绝大多数节点成功复制”和“某个日志被绝大多数节点成功复制并且这条日志的Term和 Leader 的当前Term相同”两种条件下的情况。

a. S1 是Leader，其他节点部分的复制了索引位置 2 的日志条目。  
b. S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。  
c. S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。  
d. S1又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。  
e. 在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。  

注意 (c) 情形的时候，Leader S1 的当前Term是4，然而当前复制到绝大多数的日志 Term 是 2 ，如果在提交的时候没有**这条日志的Term和Leader的当前Term相同**，那么 Term 为 2 的日志就会标志为提交，然而这时主机 S1 崩溃了（也就是情形 (d) ），S5 当选为 Leader ，因为显然 S2 - S4 的日志都没有 S5 新，然而这个时候显然违背了**领导人完全特性**，因为标志为提交的日志 2 没有出现在新 Leader 的日志中。然而如果类似于 (e) 情形，只有当当前Term 4 的日志被提交的时候才标志日志为提交的话，那么 S5 根本不可能在选举中竞选成功，而关于之前任期的日志如日志 2在后面的日志复制过程中也会渐渐的同步到其他节点中。
 


## 复制状态机


























# Draft
## 选主 
- 请求投票
## 正常操作
- `requestVote()`
- `duplicateLogEntry()`
- 心跳，不带`command`的`duplicateLogEntry()`操作
- 绝大多数**Follower**执行并提交之后才发`response`。=> 确保了在**Leader**挂了之后的选主阶段选出来的新**Leader**包含了所有的`committed logs`
## 安全性和一致性
### leader挂了
- `checkStatus()`归纳法证明正确性。
- `(index, term)`确定选**Leader**的时候选哪个。 => 用于保证**Leader**里面有所有`committed logs`。
### follower的一致性
- `next_index, (index, term), checkStatus()`来检查直到第一个状态一致的log。
### follower挂了
- **Leader**一直retry就行。
## 废弃的Leader
- 旧的**Leader**可能是网卡了一下，然后新的**Leader**被选出来了，所以旧**Leader**会重新`duplicateLogEntry()`
- `(index, term)`用于确定`follower()`是不是再认回来原来的**Leader**。
- $term_{old\_leader} > term_{follower\_or\_new\_leader}$，那么现在的**Leader**退位给旧**Leader**，否则旧**Leader**变成**Follower**。
## 用户规则
- 设置`timeout`，超时重发即可。
- 保证`command`**正好一次**执行。
- 大于等于一次：执行完成才提交。
- 不超过一次：通过给已提交的`command`添加`unique id`确保不会重复执行。
## 配置更改
- 2phase提交。
- *joint consensus*阶段用于确保在$C_{old,new}$的时候不会产生新的**Leader**。

## 问题
- `committed log`是**follower**自己确定的还是**leader**确定的 => **Leader**确定的。
> 如果选举超时并且没有从**Leader**收到`AppendEntries`或者给**Candidate**发投票，那么将自己变成**Candidate**

## 要点
- **提交**，[leader视角]在复制到大多数的服务器上时，就会提交，[follower视角]如果它知道有些日志已经被提交，那么它会将这个日志放到自己的状态机中。[1]
- **安全性**：
  - 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。
  - 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。
    1. 这是因为**在leader的log是只增加不会修改和减少的**
    2. 这个是根据`appendEntries`里面检查一致性决定的，它保证上一条记录相同，那么这一条记录也相同的话，那么前面的全部相同。
**正常情况**下是一致的，如果不一致那么就把**follower**不一致的记录覆盖为**leader**的记录

> 如何保证apply到状态机的是一致的?）
> 答：根据条件1，“如果它知道有些日志已经被提交，那么它会将这个日志放到自己的状态机中。”在确保提交日志一致性的情况下使得状态机保持一致性。

**Leader**开始自己的任期的时候就会把nexIndex[]设置为自己的最大log index + 1，然后根据**Follower**的一致性检查来一步步确定每个**follower**的状态。（然后如果大部分的sever上都有这个log，就会提交）
> 之前提交的怎么算？
> 如何保证每个状态机执行相同顺序的指令？。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。

通过在选主的时候增加**限制**来保证选出来的**Leader**拥有提交过的所有记录。这个限制就是：
- 新选出来的**Leader**的log必须比绝大多数的服务器节点新。通过term和index比较，Term越大越新，index越长越新。

> 为什么在5.4.2节（b）阶段S5不能获得S2的选票？为什么S5不是任期2获得的选票，而不是S2在任期2当上Leader

前一轮 Term 未 Commit 的 LogEntry 的 Commit 依赖于高轮 Term LogEntry 的 Commit。

只有领导人当前任期里的日志条目通过计算副本数目可以被提交（只有当前任期的log提交并且大部分的server都将logappend到自己的logs里面才能算提交），也就是说之前的不用管。
**然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。**这个意思是，之前任期（比如现在的Term是5，之前的是3）如果Term是3的某个log是被大多数server拥有，那么也不能确定它就是被提交了的。（因为有可能在上一个任期2虽然有大部分sever有记录a，但是在leader A提交之前崩溃掉了，这个时候如果LeaderA恢复执行任期4的时候尝试提交记录a的话，有可能被另一个任期3的取代掉，然后覆盖已经提交的2）如果采用新任期的计算方法的话，那么哪个任期3的sever根本不可能选举成功。

## 配置更改（集群成员变化）
引入**共同一致**阶段。
- 日志条目被复制给集群中新、老配置的所有服务器。
- 新、旧配置的服务器都可以成为领导人。
- 达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。

> 为什么强制Cold,new同时有的才能被选举为Leader