# 事务隔离级别
## READ UNCOMMITTED（读未提交）
该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为**脏读**。

## READ COMMITTED（读提交）
一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为**不可重复读**问题，Oracle 和 SQL Server 的默认隔离级别。  
不可重复读的意思是在一个事务中在时刻A看到的和在时刻B看到的同一条记录可能不一样，因为**只能读已经提交的修改**，所以在A时刻记录的修改没有被提交，而在B时刻记录的修改被提交，所以两次读的结果不一样。

## REPEATABLE READ（可重复读）
该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有**幻读**现象。MySQL 的 InnoDB 引擎可以通过 `next-key locks` 机制（参考下文"行锁的算法"一节）来避免幻读。

**幻读**的一个例子是明明查不到数据，但是往表里面插入数据的时候会报错。

## SERIALIZABLE（序列化）
在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。

序列化隔离级别下的事务读操作只有在另一个事务提交后才能执行，否则会被挂起，串行的顺序是事务开启的顺序，串行化之后事务的执行结果和真正的串行执行是一样的。

## 隔离级别和问题表
|隔离级别|	脏读|	不可重复读|	幻读|
|----|---|---|---|
|读未提交	|可以出现|	可以出现|	可以出现|
|读提交	|不允许出现	|可以出现|	可以出现|
|可重复读	|不允许出现	|不允许出现	|可以出现|
|序列化|	不允许出现|	不允许出现	|不允许出现|

## 锁的优化建议
锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。

合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。
尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。
尽量控制事务的大小，减少锁定的资源量和锁定时间长度。
在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。
