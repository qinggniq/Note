#      并发理论

> **事务**是一个在数据库上面的多个操作序列来执行一些high level的函数

这个DBMS最小的改变单元

- 部分事务是不允许的

 

**一个简单的系统**

按照事物到达的时间一个一个的执行，一个并且只有一个个事务可以同一时间运行。

在事务开启之前，给现在的数据库做备份

- 如果事务成功，那么重写原来的数据库文件
- 如果失败， 那么删除现在操作的数据库文件



但是这个系统太慢了，我们需要允许并行执行事务。

- 更好的性能/吞吐率
- 降低响应时间

但是在性能的要求下我们依然需要

- 正确性
- 公平性

但是正确性和高效性依然很难。

**问题**

在执行过程中任意的打断（多线程执行的时候可能会在指令执行的任意时刻打断）可能会导致：

- 暂时的不一致
- 永久的不一致

我们需要形式化的正确规范来决定一个打断是不是有效的。

**定义**

一个事务可能有很多关于数据库的操作。

然而DBMS只关系对于数据的读写，而不关心对于**外界**的改变（比如发邮件）。

**形式化定义**

**数据库**：一个固定大小的有名对象的集合（比如 A、B、C...）

**事务**：一个读写操作的序列（R(A)、W(B)）

**正确性规范 ACID**

**原子性**：所有操作要么发生，要么不发生

**一致性**：如果在事务开始的时候数据库是一致的，那么事务结束的时候也应该是一致的。（有点强行）

**隔离性**：事务的执行与其他事务隔离。

**持久性**：如果事务提交了，那么它们应该被持久化到磁盘。

## 目录

- 原子性
- 一致性
- 隔离性
- 持久性

## 原子性

执行一个事务有两种结果

- 执行所有操作后提交
- 在执行操作的时候中断

DBMS保证事务具有原子性，要么全部发生，要么全部不发生。

### 两种abort的场景

- 在执行的时候，DBMS崩溃了
- 在执行的时候，电源断了

如何在这两个情况下保证原子性？

### 方法

- **日志**
  - 记录所有操作，然后我们可以undo被abort的事务的操作
  - 在磁盘和内存里面同时维护undo record
  - 想象这是飞机上的黑盒？？？

日志几乎被所有的DBMS采用。

- **影子分页**
  - DBMS给复制那些事物操作的页，只有事务提交了那些页才能被其他的看见。
  - 最初从System R发明。
    - CouchDB
    - LMDB



## 一致性

数据库的一致性一般通过给字段加限制条件来实现。

## 隔离性

> 在执行一个事务的时候不需要关系是不是有其他事务执行。

### 保证隔离的机制

**并发控制**协议是DBMS决定多个事物是如何进行操作的。

有两类机制：

- **悲观机制**：在第一时间不允许问题发生
- **乐观机制**：假设问题发生比较罕见，出问题的时候再去解决。

### 交错机制

如果两个事务直接串行执行的话，那么效率就很低。所以需要两个事务同时执行，然而同时执行时不同的执行序列会造成不同的执行结果， 所以需要很好的控制并行的顺序。

![image-20200204200234822](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200204200234822.png)

### 调度的形式化的属性

- **串行调度**
  - 这个调度不交错执行多个事务
- **等价调度**
  - 对于任意数据库状态，执行第一个调度和第二调度的效果是一样的
  - 算术操作不影响？
- **可序列化调度**
  - 这个调度等价于一些事务串行调度
  - 如果每个事务保证一致性，那么可序列化调度保证一致性

### 冲突的操作

两个操作是**冲突的**如果

- 它们属于不同的事务
- 它们对一个对象操作，并且其中至少一个是写操作

#### **读-写**冲突

**不可重复读**

![image-20200204201354439](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200204201354439.png)

### **写-读**冲突

**脏读**

![image-20200204201522419](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200204201522419.png)

#### **写-写**冲突

**覆盖未提交数据**

![image-20200204201701288](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200204201701288.png)

### 冲突总结

给一些冲突，对于一个**可序列化**的调度意味着：

- 这是去检查调度是不是正确的
- 这些冲突不能指导如何去生成一个正确的调度

又不同级别的**序列化**

- 冲突可序列化
- view serializablity



### 冲突可序列化调度

两个调度是**冲突等价**的，如果：

- 他们在相同事物的操作是一样的
- 每对冲突的操作是一个顺序

调度**S**是**冲突可序列化**的，如果：

- **S冲突等价**于一些串行调度

调度**S**是**冲突可序列化**的，如果它可以通过交换不同事务之间不冲突的操作而转化为串行调度。

### 依赖图

如果数据库同时只有两个事务的话，那么判断一个调度是不是**冲突可序列化**的很简单，但是如果有很多个事务，需要用**优先图**解决。

### 视图可序列化

![image-20200204204216896](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200204204216896.png)

它不是冲突可序列化的，但是它的视图可序列化的。

![image-20200204204433280](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200204204433280.png)

## 总结

并发控制是自动的：

- 自动加入锁来调度
- 保证执行的结果和一些序列是一样的？？

