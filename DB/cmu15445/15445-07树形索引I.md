# Tree Index

> **表索引**是表属性的子集，它被组织、排序以便于更高效地访问。
>
> DBMS需要保证索引和表原有的内容保证**同步**。

- 空间（索引占用的空间）和时间（索引带来的查询的高效）的取舍
- 同步和不同步的取舍，同步（耗时/但是持久性），不同步（快/但是主机崩溃之后可能会丢失一些数据？）？？？？

## 目录

- B+ Tree overview
- 设计抉择
- 优化

### B+Tree概述

> **B+Tree**是一个自平衡的树形数据结构，他能保证数据有序提供<font color="red">log n</font>时间复杂度的查询、访问、插入、删除操作。
>
> - 通常是一个节点孩子超过两个的多叉树。
> - 用于优化系统中对大数据块的读写操作。

#### 属性

- 完全平衡数
- 节点key的数量 <font color="red">M/2 - 1 =< #keys <= M-1 </font>
- 所有有k个键的内节点有k+1个非空孩子

![image-20200122180205431](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200122180205431.png)

在b+tree里面叶子节点里面存的key和value一般不放在一起

#### 叶子结点的数据

- Record ID就是第4章讲的pageId + slotId
- 元组数据

![image-20200122180918282](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200122180918282.png)

#### B-Tree vs B+Tree

- B-Tree**里面任何结点都能存**value
- B+Tree**里面只有叶子结点才能存**value

- B-Tree会让**多线程更新操作**十分困难，而B+Tree只有叶子结点有数据，所以加锁比较方便。

#### 聚簇索引

保证索引的列排序。实际的数据也是根据这个列来进行排序的（一般是主键），所以自增主键的优势在于新插入的记录它不会叉到中间去，引起数据位置的变更，而是类似于追加的形式，很快。

## B+Tree设计抉择

- 节点大小
- merge阈值
- key的长度
- 允许有重复的key吗
- 节点内搜索（二分？）

### 节点大小

简单的原则是：

**磁盘速度越小，节点大小越大。**

- 如果大多操作是范围查找，那么用更大的节点
- 如果大多操作是随机查找，那么用更小的节点（这样实际读的数据就少一点了）

### 合并阈值

到达合并的条件的时候，DBMS一般不立即合并（因为操作太耗时间），延迟合并操作可以降低重新组织的规模。

实际数据库一般开一个后天线程进行周期性的重建工作。

### Key的长度

![image-20200122185146703](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200122185146703.png)

前两种方法没人用，一个太慢（point），一个不行，因为需要页面大小一样，而且不方便二分查找。

posgresql用的第三种，

![image-20200122190035917](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200122190035917.png)



### 重复键

1. 存储重复键

2. 一个键存多个值

### 节点内查找

1. 线性查找
2. 二分
3. 插补法

### 优化

- 前缀压缩
- 后缀截断
- 块插入
- pointe

#### 前缀压缩

如果有很多key有相同的前缀（比如url），提取前缀然后存key不一样的地方。

#### 后缀截断

只保存**最小的可以区分key的前缀**

#### 块插入

建立B树最快的方式就是在已有的数据上建B+树（自底向上），而不是一个一个的插。

#### 指针

一般value存pageID，但是如果page已经在buffer pool里面了，那么就value就直接存指针就行了，避免了一次查找操作。