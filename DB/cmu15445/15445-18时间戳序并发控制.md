# 时间戳并发控制

- **两阶段锁**（2PL）
  - 在事务执行的时候决定**冲突操作**的顺序 [**悲观的**]
- **时间戳序**（T/O）
  - 在执行之前决定序列化的顺序[**乐观的**]

**基本理论**

使用**时间戳**来决定事务执行的顺序。

给$TS(T_1) < TS(T_2)$，需要保证事务的执行结果看起来是$T_1$在$T_2$之前执行。

**时间戳分配**

每个事务都会被分配一个唯一的单调增的时间戳。

- 系统时钟
  - 时间回滚，这个时钟是可以被修改的
- 逻辑时钟
  - 32-bit的Counter到达最大之后就会溢出，导致时间回滚
- 两者的混合

## 目录

- 基本的时间戳序协议
- 并发控制的优化
- 基于分区的时间戳序
- 隔离级别

## 基本的时间戳序协议

事务无锁地读写对象。

每个对象都会被记录最近操作的时间戳

- **W-TS(X)**——X对象的写时间戳
- **R-TS(X)**——X对象的读时间戳

对每个操作检查时间戳

- 如果一个事务想要访问**时间戳大于现在时间**的对象，那么这个事务将会被取消或者重试

### 读操作

if $TS(T_i) < W-TS(X)$，这个违反了对象X的写时间戳顺序。

- 使用新的时间戳重试$T_i$

else：

- 允许$T_i$读X对象
- 更新**R-TS(X)**为$max(R-TS(X), TS(T_i))$
- 创建一个X对象的本地复制来保证**可重复读**

### 写操作

if $TS(T_i) < R-TS(x)$ or $TS(T_i) < W-TS(X)$

- 重试$T_i$

else:

- 允许$T_i$写对象X，更新$W-TS(X)$
- 创建一个X对象的本地复制来保证**可重复读**

### ps

要注意的是前面两个比较操作比较的是**事务的时间戳**而不是**事务操作的时间戳**。

### THOMAS写法则

if $TS(T_i) < R-TS(X)$

- 重试$T_i$

if $TS(T_i) < W-TS(X)$

- **THOMAS写法则**：忽略这个写，然后允许事务继续下去
- 这违反了$T_i$的时间戳序

else

- 允许$T_i$写X，并更新$W-TS(X)$

![image-20200206203156055](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200206203156055.png)

就以上图为例，$T_1$本来不能写这个A，因为$TS(T_1) < W-RS(A)$，然而$T_1$的写操作并不影响数据库（因为A对象的最终值理应是$T_2$写入的值，因为$T_2$是在$T_1$之后发生的），并且在$T_1$中已经保留了A的局部拷贝，所以我们可以忽略$T_1$中的写操作，然后继续执行。

### 总结

时间戳序并发控制生成一个**冲突可序列化**的调度如果你不用**Thomas写法则**的话。

- 没有死锁，因为没有事务需要等
- 如果有很多短事务造成冲突，那么可能造成长事务的饥饿

并且它不是**可恢复的**调度，如果一个事务的操作使用了其他事务的中间写的结果并且那个事务崩溃/回滚了，那么DBMS检测不出此类事件的发生。

## 并发控制的优化

如果事务大多是**短事务**，并且冲突发生的很少，那么基于这些假设，我们可以做哪些优化呢？

DBMS为每个事务创建一个*workspace*，

- 任何对象的读，被拷贝到这个workspace
- 对对象的修改被应用到这个worksapce

当一个事务提交，DBMS比较workspace**写集合**，看是不是和其他事务冲突。

如果没有冲突，那么这个**写集合**被并入到全局的数据库里面。

### OCC

这个优化将事务分成了三个阶段

- **读阶段**
  - 也叫做**事务执行阶段**
- **验证阶段**
  - 验证**写集合**是不是和其他事务冲突
  - 每个事务的$TS$不是事务执行的那个时间戳了，而是验证阶段的时间戳？？？
- **写阶段**
  - 把**写集合**写到数据库里面



#### 读阶段

读阶段就是读操作的时候把数据库的对象拷贝到局部对象

#### 验证阶段

当一个事务**COMMIT**，DBMS检查事务是否有冲突。

验证有两种验证

- 后向验证
- 前向验证

**后向验证**

检查这个事务的读写集合有没有和其他**已经提交的**事务有交集。

**向前验证**

检查这个事务的读写集合有没有和其他**还没提交的**事务有交集。

### 验证的一些细节

#### case 1

一个事务在另一个事务开始的时候就完成了所有操作。

这个很简单，没有情况讨论。

#### case 2

$T_i$完成所有阶段，在$T_j$完成**写阶段**之前。

$T_i$不应该写那些被$T_j$读的对象：

- $WriteSet(T_i) \cap ReadSet(T_j) = \emptyset $

![image-20200206220342009](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200206220342009.png)

#### case 3

$T_i$完成**读阶段**，在$T_j$完成**读阶段**之前。

$T_i$不应该写任何$T_j$写过或者读过的对象。

- $WriteSet(T_i) \cap ReadSet(T_j) = \emptyset $
- $WriteSet(T_i) \cap WriteSet(T_j) = \emptyset $

### 总结

OCC在下面的情况下工作的很好

- 所有的事务都是读事务
- 事务的访问都没有交集

如果数据库很大，并且工作负载不是倾斜的，那么发生冲突的概率很低，用锁很浪费。。

#### 一些缺点

- 局部数据大量拷贝
- 验证/写阶段的性能瓶颈
- **取消**事务的代价更大，因为需要把事务里面的操作全部执行才能判断该不该提交

如果有很多并发执行的事务，那么即使冲突的操作很少，但是检查冲突的操作加起来就很大了，因为这些检查操作都需要获取**latch**。

## 基于分区的时间戳序并发控制

把数据库水平分区，就是不同的分区数据没有关联。

使用时间戳去给不同分区里面串行执行（每个分区一个线程）的事务排序

- 只检查在一个分区里面并发执行的事务的冲突

### 细节

每个事务通过它们到达DBMS的时间来赋予时间戳。

每个分区通过一个锁来保护：

- 每个事务放到对应的分区队列
- 时间戳最小的事务获得相应分区的锁
- 事务开始执行，因为一个分区最多一个事务同时执行，所以它可以获得分区里面对象的所有锁

### 读

读操作需要获得锁。

如果一个事务在没有锁的情况下访问一个分区，那么它将会被终止然后重试。

### 写

所有的写操作都是原地修改，和之前OCC和基本的基于时间戳序的并发控制不一样。

- 在内存里面维护一个buffer来回滚之前的修改，如果这个事务被终止了的话

如果一个事务在没有锁的情况下写一个分区，那么它将会被终止然后重试。

### 性能问题

基于分区的时间戳序并发控制是高效的，如果：

- DBMS在事务开始之前知道事务需要哪些分区
- 绝大多数事务只访问一个分区

多分区事务导致在执行的过程中分区的浪费，因为在执行的时候一个时刻只能在一个分区执行，于此同时那些被这个多分区事务锁住的分区就不能服务其他的事务了。

## 一些问题

上面的这些理论只涉及到了读写，但是数据库还有删除/插入这种操作，所以就会引发新的问题。

### 幻影读

![image-20200206225402869](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200206225402869.png)

为什么会发生？

- 因为$T_1$只能锁住已有的记录，而不能锁住不存在的记录

**冲突可序列化**只能对对象的集合确定的单个对象的读写保证可序列化级别。

### 谓词锁

**有索引**

如果有一个索引，那么可以锁住满足条件的index page。

如果这个没有一个记录满足条件，那么事务必须锁住这个记录应该存在的index page。

**没有索引**

如果没有合适的索引，那么一个事务必须获得

- 一个锁住所有含有满足条件记录所在页的锁，防止对记录的修改
- 这个表本身的锁，防止对满足条件记录的插入或删除



### 重复扫描

另一个办法是在事务提交的时候重复扫描，看看是不是和之前获得的结果一样

- 必须重复扫描所有的范围查询