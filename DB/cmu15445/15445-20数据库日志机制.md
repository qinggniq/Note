# Database Logging Schemes

崩溃恢复算法用来确保数据库的一致性、事务原子性、和失败后的持久性。

恢复算法有两部分：

- 在事务正常处理的过程中的操作（日志），保证DBMS能从失败中恢复
- 在失败后将数据库恢复到某个状态以保证**ACD**的操作

## 目录

- 错误类型
- 缓存池策略
- 影子页（shadow paging）
- WAL
- 日志方案
- 检查点

## 错误类型

- **1**：事务错误
- **2**：系统错误
- **3**：存储媒介错误

### 事务错误

- **逻辑错误**
  - 事务因为一些内部错误导致不能完成，比如违反约束条件
- **内部状态错误**
  - DBMS因为一些原因（比如死锁）必须终止一个事务

### 系统错误

- **软件错误**
  - 数据库实现，比如无法捕获的除零错误
- **硬件错误**
  - 主机断电了
  - **失败就停止的假设**：非易失性存储的内容被认为不会被系统崩溃而影响

### 存储媒介错误

- **不可修复的硬件错误**
  - 硬件存储部分或全部被摧毁
  - 这些破坏被认为是可以检测到的（硬件控制器用checksum来检测错误）

没有DBMS可以从这个错误恢复。DBMS只能恢复到备份的版本状态。

### 总结

数据库主要存储在非易失性存储里面，但是易失性存储操作比较快。一般使用内存来作访问

- 先拷贝到内存
- 然后写内存
- 然后把内存里面的写回磁盘

所以DBMS需要保证一下几点

- 一旦DBMS宣称一个事务已经被提交，那么这个事务的修改必须被持久化
- 如果事务被中止，那么没有中间状态被持久化

## 缓存池策略

- **undo**：移除一个中止/未完成事务的影响
- **redo**：重新施加一个已提交的事务的修改

 如何实现取决于我们如何管理缓存池。

### STEAL策略

DBMS是否应该允许一个未提交事务在非易失性存储中覆盖最近提交的值。

**STEAL**：允许

**NO-STEAL**：不允许

### FORCE策略

DBMS是否允许在事务提交之前事务的修改需要体现到非易失性存储中。

**FORCE**：需要

**NO-FORCE**：不需要

### NO-STEAL + FORCE

![image-20200209151906848](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200209151906848.png)

优点：

- 不需要undo，因为没有提交的事务修改没有落盘
- 不需要redo，因为所有提交过的事务修改落盘了（假设磁盘写的原子性）

缺点：

- 一个页面可能被写入很多次
- 硬盘的原子写取决于硬盘块的大小，如果事务的修改很大，那么写的时候就无法保证原子性
- 由于没有提交的事务的修改不能体现到非易失性存储里面，所以所有没有提交的事务的修改的内存要在内存的大小限制之内

## 影子页（shadowpaging）

给数据库为每个页维护两个拷贝

- **master**：仅包含已提交的事务的改变
- **shadow**：未提交事务修改的临时数据库

事务只在**shadow**拷贝里面更新，当事务提交，自动切换**shadow**成为新的**master**页。

DBMS只在写的时候拷贝页。

![image-20200209164234445](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200209164234445.png)

在更新数据的时候创建**shadow**页，提交的时候把root换成**shadow**页表，然后把root的信息页写进磁盘。

#### 缺点

拷贝pagetable耗时

- pagetable的结构类似于B+树
- 不需要拷贝整个树，只需要拷贝从根结点到改变的叶子结点的路径

提交的负载高：

- 需要刷新所有的页、页表、和root
- 数据会有碎片
- 需要GC
- 只同时支持一个写事务或者批量提交

sqlite使用的是

- 在数据库写一个页的时候，DBMS把原有的页写进单独的日记文件
- 当数据库执行事务的时候崩溃，如果日记文件里面有内容，那么我们就可以日记文件里面恢复之前的数据库内容

### 总结

影子页需要DBMS在磁盘上面执行随机非连续的页读写，需要将随机写变成顺序写。

## WAL

独立于数据文件维护一个包含事务对数据库的修改的日志文件。

- 假设日志在可靠存储
- 日志包含足够的信息用于数据库undo和redo

DBMS必须在对象刷新到磁盘之前就把相应的修改日志写到日志文件里面。

缓存池策略：**STEAL** + **NO-FORCE**

### WAL协议

DBMS在缓存池里面存储所有的事务日志记录。

所有关于更新页的日志记录必须在页被写到磁盘之前就追加到日志文件之后。

一个事务只有在它的日志文件都被写到磁盘上面才能提交。

WAL中存储一下信息

- 事务ID
- 对象ID
- 对象之前的值（UNDO）
- 对象之后的值（REDO）

### WAL实现

DBMS什么时候写日志到磁盘？

- 事务提交
- 可以用**组提交**来批量写日志文件，就是定时（时间到了）/定量（缓存满了）。。因为WAL有足够的信息undo

DBMS什么时候把脏记录写回磁盘？

- 每次事务执行更新的时候？ redo的时间减小了，update的时间增加了
- 每次事务提交的时候？undo时间

## 缓存策略的抉择

![image-20200209173509181](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200209173509181.png)

## 日志方案

### 物理日志

- 记录数据库中具体位置的改变
- 例子：git diff

### 逻辑日志

- 记录事务执行的high-level的操作
- 不局限于单个页
- 例子：事务中`update, delete, insert`的查询

### 物理 vs 逻辑

相比于物理日志，逻辑日志需要更少的数据。

如果你有并发的事务，那么逻辑日志情况下的恢复工作很困难：

- 难以决定数据库的哪些部分是崩溃之前的
- 时间更长，因为需要重新演绎一遍命令

### 物理逻辑日志

物理和逻辑日志的结合，记录的是单个页的修改，但是并不假定数据的组织方式。

这个在数据库中最为流行。

![image-20200209190644361](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200209190644361.png)

## 检查点

WAL日志不可能一直增长下去，如果数据库崩溃一次，仅仅用WAL日志来恢复的话，那么必须重新一遍，十分低效。

DBMS周期性的做检查点，就是将buffer全部刷新到磁盘里面。

输出所有在主内存里面的日志的记录，然后输出修改的块到磁盘里面，在log里面append一个**<checkpoint>**标识，然后刷新到磁盘。

一般系统都会开一个后台线程来执行这个操作。。

![image-20200209191555866](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200209191555866.png)

### 挑战

- 在做检查点的时候我们需要停止所有的事务的执行，为了一致的快照。
- 扫描日志找到没有提交的事务需要花费很长时间
- 多久一次做检查点是个问题
  - 太频繁导致服务降级
  - 太久导致恢复/做检查点（刷新到磁盘）时间变长

## 总结

WAL几乎是处理易失性存储丢失信息的最好方法。

- 使用增量更新（**STEAL + NO-FORCE**）和检查点
- 在恢复的时候：**undo**没有提交的事务 + **redo**提交了的事务



