# MVCC

> DBMS在数据库中为一个逻辑对象维护多个物理版本。

- **写**：当事务写的时候，DBMS为这个对象创建一个新的版本
- **读**：当事务读的时候，它读到的是这个**事务开始的时候**这个对象最近的版本

和**OCC**（优化的并发控制）的区别在于OCC它会为每个事务维护一个私有的局部空间，第一次读的时候和最后写的时候会触发拷贝。而MVCC里面都是全局的。

它的优点在于：

- **读不会影响写**
- **写不会影响读**

只读事务可以无锁的读一个一致性的快照。

- 使用时间戳来决定可见度

几乎所有的新的数据库都用到了MVCC。

## MVCC的设计抉择

MVCC并不是一个并发控制协议（之前说的两阶段锁、时间戳序并发控制），而是事务并发的整个设计。

- 并发控制协议
- 版本存储
- 垃圾回收
- 索引管理

## 并发控制协议

- **1**：时间戳序
  - 赋予事务时间戳来决定串行顺序
- **2**：优化的并发控制（OCC）
  - 三阶段协议（读、验证、写）
  - 对于新的版本使用私有的workspace
- **3**：两阶段锁
  - 在对数据库对象进行相应操作前获得相应的锁

## 版本存储

DBMS使用元组链表字段为每个逻辑元组创建**版本链**。

- 让DBMS运行的时候找到事务对应的可见的版本
- 索引指向的是链的头（头最最新的还是最旧的取决于实现）

不同的存储引擎决定如何/何地存储各个版本。

- **1**：只追加存储
  - 新的版本追加到想相同的表空间
- **2**：时间线存储 time-travel storage
  - 老的版本被复制到独立的表空间
- **3**：增量存储
  - 原来被修改过的属性被复制到独立的增量记录空间

### 只追加存储

![image-20200208161447868](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200208161447868.png)

头最最新的还是最旧的取决于实现

#### 最旧到最新

- 每个新的版本直接追加到链尾
- 在查找的时候必须遍历整个链？

#### 最新到最旧

- 有新版本之后索引必须更新
- 不必在查找的时候必须遍历整个链？

### time-travel存储

 ![image-20200208161926735](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200208161926735.png)

### 增量存储

![image-20200208162135429](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200208162135429.png)

和time-travel的区别在于time-travel存元组里面的所有值，而增量存储只存储修改的值，所以如果想从最新版本还原到某个版本就需要遍历的时候重新演绎。。

## 垃圾回收

DBMS需要从数据库里面移除**可恢复的**物理版本。

- 这个版本没有**活跃的**事务可以看到了
- 这个版本属于被终止的事务

设计抉择

- 如何找找到过期版本
- 如何决定回收空间是不是安全

### 两个方法

- **1**：元组级别
  - 找到最旧的版本，然后验证它们是不是可以被回收
  - **background Vacuuming** vs **Cooperative Cleaning**
- **2**：事务级别
  - 每个事务维护它们的旧版本，然后DBMS就不需要扫描了

#### **background Vacuuming**

开一个后台线程，周期性的扫描，找到可以被回收的回收。可以用一个位图来存储哪些页需要被回收。

#### **Cooperative Cleaning**

工作线程在遍历的时候就判断是不是可以被回收，然后直接回收，这个方法适用于链头是最旧的版本。

#### **事务级别GC**

每个事务维护它们的读写集合，DBMS决定这些已经完成的事务的所有版本都不需要了。

## 索引管理

主键的索引指针指向版本链头，

- DBMS更新索引的频率取决于在元组更新的时候系统是不是创建一个新的版本
- 如果事务更新一个元组的属性，那么这个操作可以为视作删除这个元组然后诧异一条元组

**二级索引**

- **1** ：逻辑指针
  - 给每个元组赋予一个不会改变的唯一的标识符
  - 需要额外的中间层 （逻辑指针到物理指针）
  - 主键 vs tuple id（record id？不对）
- **2**：物理指针
  - 版本链里面存物理地址

**逻辑指针**的优势在于更新一个索引可以更新所有的索引

主键是存主键，tuple id需要加一个hash表。。。

**物理指针**的优势在于二级索引查找的时候更快

两个的优点也是对方的缺点。

## MVCC在不同系统的实现

![image-20200208172116604](/Users/qinggniq/Library/Application Support/typora-user-images/image-20200208172116604.png)

## confuse

DBMS会维护一个事务状态表，因为如果事务终止并重试了，它们的时间戳也要发生变化？

