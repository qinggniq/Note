# [818. 赛车](https://leetcode-cn.com/problems/race-car/)

## 题面

你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）

你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。

当车得到指令 "A" 时, 将会做出以下操作： position += speed, speed *= 2。

当车得到指令 "R" 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。  (当前所处位置不变。)

例如，当得到一系列指令 "AAR" 后, 你的车将会走过位置 0->1->3->3，并且速度变化为 1->2->4->-1。

现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。

示例 1:
输入: 
target = 3
输出: 2
解释: 
最短指令列表为 "AA"
位置变化为 0->1->3
示例 2:
输入: 
target = 6
输出: 5
解释: 
最短指令列表为 "AAARA"
位置变化为 0->1->3->7->7->6
说明:

1 <= target（目标位置） <= 10000。

## 思路

我们用 $A^k$表示连续使用 k 次 AA 指令，这样就可以$ A^{k_1} R A^{k_2} R \cdots A^{k_n}, k_i \geq 0$表示任意一种指令列表。注意到最优的指令列表不可能以 RR 结束，因为在到了终点后转向是无意义的；同样最优的指令列表也不必以 RR 开始，假设$ R A^{k_1} R A^{k_2} \cdots R A^{k_n}$  是一种最优的指令列表，那么我们可以将 $R A^{k_1} R$根据 nn 的奇偶性将其变为 $R A^{k_1}$或$ RR A^{k_1}$放在指令列表的末尾。

对于指令列表 $A^{k_1} R A^{k_2} R \cdots A^{k_n}$，它可以使得赛车到达的位置为 $(2^{k_1} - 1) - (2^{k_2} - 1) + (2^{k_3} - 1) - \cdots$，因此不失一般性，可以交换 $k_1, k_3, \cdots$ 这些奇数位置的 $k_i$ 使得这个数列单调不增，同样可以交换$k_2, k_4, \cdots$ 这些偶数位置的$ k_i$ 
使得这个数列单调不增。同时所有的 $k_i$ 都有一个上界 $a + 1$，其中 $a$ 为最小满足$ 2^a \geq \text{target}$的整数，即如果在某一时刻赛车经过了终点，那么折返比继续行驶更优。



我们可以使用动态规划来找到最短的指令长度。

假设我们需要到达位置 x，且 $2^{k-1} \leq x < 2^k$我们用$ dp[x]$ 表示到达位置 x 的最短指令长度。如果$ t = 2^{k-1}$，那么我们只需要用 $A^k$ 即可。否则我们需要考虑两种情况：

1. 我们首先用 $A^{k-1}$到达位置$ 2^{k-1} - 1$，随后折返并使用 $A^j$，这样我们到达了位置 $2^{k-1} - 2^j$，使用的指令为 $A^{k-1} R A^k R$，长度为 $k - 1 + j - 2$，剩余的距离为 $x - (2^{k-1} - 2^j) < x$；
2. 我们首先用 $A^k$到达位置 $2^k - 1$，随后仅使用折返指令，此时我们已经超过了终点并且速度方向朝向终点，使用的指令为 $A^k R$，长度为 $k + 1$，剩余的距离为$ x - (2^k) - 1 < x$



## 代码

```c++
class Solution {
public:
    int racecar(int target) {
        const int n = target + 3;
        vector<int> dp(n, INT_MAX/2);
        dp[0] = 0; dp[1] = 1; dp[2] = 4;
        for (int t = 3; t <= target; ++t) {
            int k = getMax(t);
            if (t == (1 << k) - 1){
                dp[t] = k;
                continue;
            }

            for (int i = 0; i < k - 1; ++i) {
                dp[t] = min(dp[t], dp[ t - (1 << (k - 1)) + (1 << i) ] + k - 1 + 2 + i);
            }
            if ((1<<k) - 1 - t < t)
                dp[t] = min(dp[t], dp[ (1 << k) - 1 - t] + k + 1);
            
        }
        return dp[target];

        
    }
    int getMax(int t) {
        int top = -1;
        for (int i = 0; i < 32; ++i) {
            if ((1 << i) & t) {
                top = i;
            }
        }
        return top + 1;
    }
};
```

